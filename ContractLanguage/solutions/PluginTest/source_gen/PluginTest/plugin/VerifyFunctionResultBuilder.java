package PluginTest.plugin;

/*Generated by MPS */

import com.mbeddr.analyses.cbmc.rt.counterexample.lifted.builder.CBMCLiftedResultBuilder;
import com.mbeddr.analyses.cbmc.rt.counterexample.raw.CBMCRawResult;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import com.mbeddr.analyses.cbmc.rt.counterexample.lifted.model.CBMCLiftedCounterexampleState;
import com.mbeddr.analyses.cbmc.rt.counterexample.lifted.builder.DebuggingUtils;
import com.mbeddr.analyses.cbmc.rt.counterexample.raw.RawCounterexampleState;
import com.mbeddr.analyses.cbmc.rt.counterexample.lifted.builder.CBMCInitializationNoiseRemover;
import com.mbeddr.analyses.cbmc.rt.counterexample.lifted.builder.StructuresAndArraysAssignmentsFlattener;
import com.mbeddr.analyses.cbmc.rt.counterexample.lifted.builder.CBMCRawNoiseFilter;
import com.mbeddr.analyses.cbmc.rt.counterexample.lifted.model.CBMCLiftedResult;
import com.mbeddr.analyses.cbmc.core.rt.analyses.asserts.CBMCAssertResult;
import com.mbeddr.analyses.cbmc.rt.counterexample.lifted.builder.CounterexampleLifterBase;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import jetbrains.mps.smodel.structure.ExtensionPoint;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.backports.Deque;
import jetbrains.mps.internal.collections.runtime.DequeSequence;
import com.mbeddr.analyses.cbmc.rt.counterexample.lifted.builder.FunctionCallsAndReturnsLifterBase;
import com.mbeddr.analyses.cbmc.rt.counterexample.lifted.builder.NodesFinderFacade;
import com.mbeddr.analyses.cbmc.rt.counterexample.lifted.model.FailState;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import java.util.Collections;
import java.util.Comparator;

public class VerifyFunctionResultBuilder extends CBMCLiftedResultBuilder {

  public static VerifyFunctionResult buildVerifyFunctionResult(CBMCRawResult rawResult, SNode analyzedConcept, String cbmclevelUserFriendlyMessage) {

    List<CBMCLiftedCounterexampleState> liftedStates = null;
    {
      Runtime rt = Runtime.getRuntime();
      long initiallyUsedMemory = (rt.totalMemory() - rt.freeMemory()) / (1024 * 1024);
      long startingTime = System.currentTimeMillis();
      {
        DebuggingUtils.printRawStates("Initial raw states", rawResult.getStates(), DEBUG);
        List<RawCounterexampleState> filteredInitNoise = CBMCInitializationNoiseRemover.removeInitializationNoise(rawResult.getStates());
        DebuggingUtils.printRawStates("After initialization noise was removed", filteredInitNoise, DEBUG);
        List<RawCounterexampleState> flattenedRawStates = StructuresAndArraysAssignmentsFlattener.flatten(filteredInitNoise);
        DebuggingUtils.printRawStates("After structures assignments were flattened", flattenedRawStates, DEBUG);
        List<RawCounterexampleState> filteredRawNoise = CBMCRawNoiseFilter.filter(flattenedRawStates);
        DebuggingUtils.printRawStates("Raw noise is filtered out", filteredRawNoise, DEBUG);

        liftedStates = interpretRawStates(filteredRawNoise);
        DebuggingUtils.printLiftedStates("After raw states are interpreted", liftedStates, DEBUG);
      }
      long finallyUsedMemory = (rt.totalMemory() - rt.freeMemory()) / (1024 * 1024);
      System.out.println("------------- Building the Lifted Result --------------" + " time: " + (System.currentTimeMillis() - startingTime) + "ms; initial used mem. " + initiallyUsedMemory + "MB; finally used mem. " + finallyUsedMemory + "MB");
    }

    CBMCLiftedResult lifted = CBMCLiftedResultBuilder.buildCBMCLiftedResult(rawResult, analyzedConcept);
    return new VerifyFunctionResult(lifted, cbmclevelUserFriendlyMessage);

    // <node> 
  }

  public static CBMCAssertResult buildNoVerifyFunctionFoundResult(CBMCRawResult rawResult, SNode analyzedConcept) {
    return new CBMCAssertResult(rawResult, rawResult.getDelayInMillis(), analyzedConcept);
  }


  private static List<CBMCLiftedCounterexampleState> interpretRawStates(List<RawCounterexampleState> rawStates) {
    List<CounterexampleLifterBase> assignmentsLifters = ListSequence.fromList(new LinkedList<CounterexampleLifterBase>());
    List<CounterexampleLifterBase> functionsCallsLifters = ListSequence.fromList(new LinkedList<CounterexampleLifterBase>());
    List<CounterexampleLifterBase> functionsReturnsLifters = ListSequence.fromList(new LinkedList<CounterexampleLifterBase>());

    ExtensionPoint<CounterexampleLifterBase> assigProvider = ExtensionPoint.<CounterexampleLifterBase>generify(new ExtensionPoint("com.mbeddr.analyses.cbmc.AssignmentsLifterProvider", CounterexampleLifterBase.class));
    for (CounterexampleLifterBase al : Sequence.fromIterable(assigProvider.getObjects())) {
      ListSequence.fromList(assignmentsLifters).addElement(al);
    }

    Deque<SNode> callStack = DequeSequence.fromDeque(new LinkedList<SNode>());
    ExtensionPoint<FunctionCallsAndReturnsLifterBase> funcCallsProvider = ExtensionPoint.<FunctionCallsAndReturnsLifterBase>generify(new ExtensionPoint("com.mbeddr.analyses.cbmc.FunctionCallsLifterProvider", FunctionCallsAndReturnsLifterBase.class));
    for (FunctionCallsAndReturnsLifterBase fcl : Sequence.fromIterable(funcCallsProvider.getObjects())) {
      fcl.setCallStack(callStack);
      ListSequence.fromList(functionsCallsLifters).addElement(fcl);
    }

    ExtensionPoint<FunctionCallsAndReturnsLifterBase> funcReturnsProvider = ExtensionPoint.<FunctionCallsAndReturnsLifterBase>generify(new ExtensionPoint("com.mbeddr.analyses.cbmc.FunctionReturnsLifterProvider", FunctionCallsAndReturnsLifterBase.class));
    for (FunctionCallsAndReturnsLifterBase frl : Sequence.fromIterable(funcReturnsProvider.getObjects())) {
      frl.setCallStack(callStack);
      ListSequence.fromList(functionsReturnsLifters).addElement(frl);
    }

    sortLiftersByPriority(assignmentsLifters);
    sortLiftersByPriority(functionsCallsLifters);
    sortLiftersByPriority(functionsReturnsLifters);

    List<CBMCLiftedCounterexampleState> result = ListSequence.fromList(new LinkedList<CBMCLiftedCounterexampleState>());
    for (RawCounterexampleState crtRawState : ListSequence.fromList(rawStates)) {
      try {
        List<CounterexampleLifterBase> lifters = ListSequence.fromList(new LinkedList<CounterexampleLifterBase>());
        List<CBMCLiftedCounterexampleState> states = ListSequence.fromList(new LinkedList<CBMCLiftedCounterexampleState>());

        switch (crtRawState.getKind()) {
          case ASSIGNMENT:
            lifters = assignmentsLifters;
            break;
          case FUNCTION_CALL:
            lifters = functionsCallsLifters;
            break;
          case FUNCTION_RETURN:
            lifters = functionsReturnsLifters;
            break;
          case FAILURE:
            SNode originalNode = NodesFinderFacade.findOriginalNode(crtRawState);
            ListSequence.fromList(states).addElement(new FailState(originalNode, crtRawState.getFailKind()));
            break;
          default:
        }

        for (CounterexampleLifterBase crtLifter : ListSequence.fromList(lifters)) {
          if (crtLifter.canLift(crtRawState, rawStates)) {
            boolean isNoise = crtLifter.isNoise(crtRawState, rawStates);
            if (DEBUG) {
              String origNode = SPropertyOperations.getString(SNodeOperations.getConceptDeclaration(NodesFinderFacade.findOriginalNode(crtRawState)), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"));
              String lifterName = crtLifter.getClass().getSimpleName();
              int step = crtRawState.getStepNr();
              String noiseMsg = (isNoise ? " SKIPPED AS NOISE " : "");
              System.err.println("step: " + step + ",\t origNode: " + origNode + ",\t\t lifted with: " + lifterName + noiseMsg);
            }
            if (!(isNoise)) {
              states = crtLifter.lift(crtRawState, rawStates);
            }
            break;
          }
        }

        for (CBMCLiftedCounterexampleState state : ListSequence.fromList(states)) {
          state.setStepNumber(crtRawState.getStepNr());
          state.setThreadNumber(crtRawState.getThreadNumber());
          ListSequence.fromList(result).addElement(state);
        }
      } catch (Exception e) {
        // make sure that whatever bad happens in lifting a state, we continue with the next ones 
        e.printStackTrace();
      }
    }

    return result;
  }

  private static void sortLiftersByPriority(List<CounterexampleLifterBase> lifters) {
    Collections.sort(lifters, new Comparator<CounterexampleLifterBase>() {
      public int compare(CounterexampleLifterBase p0, CounterexampleLifterBase p1) {
        // sort descending 
        if (p1.priority() < p0.priority()) {
          return -1;
        }
        if (p1.priority() == p0.priority()) {
          return 0;
        }
        return 1;
      }
    });
  }


}
